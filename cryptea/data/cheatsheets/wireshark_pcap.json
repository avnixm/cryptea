{
  "title": "Wireshark & PCAP Analysis",
  "category": "Network",
  "description": "Network traffic analysis, packet inspection, protocol dissection, and data extraction from PCAP files using Wireshark and tshark.",
  "entries": [
    {
      "name": "Wireshark Display Filters",
      "desc": "Essential display filters for isolating specific network traffic and protocols",
      "example": "# Protocol filters\nhttp\nhttp.request\nhttp.response\ndns\ndns.qry.name contains \"example\"\ntcp\ntcp.port == 80\nudp\nicmp\nftp\nftp-data\nssh\ntelnet\nsmtp\n\n# HTTP specific\nhttp.request.method == \"POST\"\nhttp.request.uri contains \"login\"\nhttp.request.uri contains \"flag\"\nhttp.response.code == 200\nhttp.response.code == 404\nhttp.cookie contains \"session\"\nhttp.authorization\nhttp.user_agent contains \"python\"\n\n# IP filters\nip.addr == 192.168.1.1\nip.src == 10.0.0.1\nip.dst == 10.0.0.2\nip.addr == 192.168.1.0/24\n\n# TCP filters\ntcp.port == 443\ntcp.stream eq 0\ntcp.flags.syn == 1\ntcp.flags.rst == 1\ntcp.analysis.retransmission\ntcp.analysis.duplicate_ack\n\n# Combined filters\nhttp and ip.addr == 192.168.1.1\ntcp.port == 80 and ip.src == 10.0.0.1\nhttp.request and http.request.uri contains \"admin\"\n\n# Follow streams\ntcp.stream eq 5  # Follow TCP stream 5\nhttp.request.method == \"POST\" and http.file_data contains \"password\"\n\n# DNS queries\ndns.qry.name == \"evil.com\"\ndns.flags.response == 1\n\n# Exclude traffic\n!arp\n!dns\n!(tcp.port == 22)\n\n# String search\nframe contains \"flag\"\nframe contains \"password\"\nhttp contains \"admin\"",
      "flag_hint": "Use 'frame contains \"flag\"' to search entire capture for keywords",
      "tags": ["wireshark", "pcap", "filters", "network"]
    },
    {
      "name": "TCP Stream Reassembly",
      "desc": "Reconstruct TCP conversations and extract files from network streams",
      "example": "# Wireshark GUI method:\n# 1. Find interesting packet\n# 2. Right-click > Follow > TCP Stream\n# 3. View full conversation\n# 4. Save as: Raw, ASCII, EBCDIC, Hex, C Arrays\n\n# Tshark command-line\n# Follow TCP stream 0\ntshark -r capture.pcap -q -z follow,tcp,ascii,0\n\n# Extract all TCP streams\nfor i in {0..100}; do\n    tshark -r capture.pcap -q -z follow,tcp,raw,$i > stream_$i.raw 2>/dev/null\ndone\n\n# Python with scapy\nfrom scapy.all import *\n\ndef extract_tcp_stream(pcap, stream_id):\n    packets = rdpcap(pcap)\n    data = b''\n    \n    for pkt in packets:\n        if TCP in pkt and Raw in pkt:\n            # Filter by stream (simplified)\n            data += bytes(pkt[Raw].load)\n    \n    return data\n\n# Extract HTTP objects\n# Wireshark: File > Export Objects > HTTP\n# Save all files transferred via HTTP\n\n# Tshark export HTTP objects\ntshark -r capture.pcap --export-objects http,output_dir/\n\n# Extract files manually\n# 1. Follow TCP stream\n# 2. Find file markers (PNG: 89504E47, ZIP: 504B0304)\n# 3. Save raw stream data\n# 4. Extract file from offset\n\n# Automated file extraction\ntshark -r capture.pcap -Y 'http.request.method == \"GET\"' \\\n    -T fields -e http.request.uri\n\ntshark -r capture.pcap -Y 'http.response' \\\n    -T fields -e http.file_data | xxd -r -p > extracted_file",
      "flag_hint": "Export HTTP objects first, then manually follow streams for non-HTTP data",
      "tags": ["wireshark", "tcp-stream", "reassembly", "extraction"]
    },
    {
      "name": "Tshark Command-Line Analysis",
      "desc": "Powerful command-line packet analysis for scripting and automation",
      "example": "# Basic usage\ntshark -r capture.pcap\n\n# Display filter\ntshark -r capture.pcap -Y 'http'\ntshark -r capture.pcap -Y 'tcp.port == 80'\n\n# Extract specific fields\ntshark -r capture.pcap -Y 'http.request' \\\n    -T fields -e http.request.method -e http.request.uri\n\n# Extract HTTP requests\ntshark -r capture.pcap -Y 'http.request' \\\n    -T fields -e http.host -e http.request.uri \\\n    -e http.user_agent\n\n# Extract POST data\ntshark -r capture.pcap -Y 'http.request.method == \"POST\"' \\\n    -T fields -e http.file_data\n\n# DNS queries\ntshark -r capture.pcap -Y 'dns.qry.name' \\\n    -T fields -e dns.qry.name | sort -u\n\n# Extract credentials\ntshark -r capture.pcap -Y 'http.authorization' \\\n    -T fields -e http.authorization\n\n# FTP credentials\ntshark -r capture.pcap -Y 'ftp.request.command == \"USER\" or ftp.request.command == \"PASS\"' \\\n    -T fields -e ftp.request.command -e ftp.request.arg\n\n# Statistics\ntshark -r capture.pcap -q -z conv,tcp\ntshark -r capture.pcap -q -z http,tree\ntshark -r capture.pcap -q -z io,phs\n\n# Protocol hierarchy\ntshark -r capture.pcap -q -z io,phs\n\n# Endpoints\ntshark -r capture.pcap -q -z endpoints,ip\ntshark -r capture.pcap -q -z endpoints,tcp\n\n# Export objects\ntshark -r capture.pcap --export-objects http,output/\ntshark -r capture.pcap --export-objects smb,output/\n\n# Convert to JSON\ntshark -r capture.pcap -T json > output.json\n\n# Live capture\ntshark -i eth0 -f 'tcp port 80'\n\n# Decrypt TLS (with key log)\ntshark -r capture.pcap -o tls.keylog_file:sslkey.log -Y 'http'",
      "flag_hint": "Use -T fields -e to extract specific data, pipe to grep for filtering",
      "tags": ["tshark", "command-line", "automation", "extraction"]
    },
    {
      "name": "DNS Traffic Analysis",
      "desc": "Analyze DNS queries and responses for data exfiltration and malicious domains",
      "example": "# DNS query analysis\n# Display filter\ndns.qry.name\ndns.qry.type == 1  # A records\ndns.qry.type == 16  # TXT records\n\n# Extract all DNS queries\ntshark -r capture.pcap -Y 'dns.flags.response == 0' \\\n    -T fields -e dns.qry.name | sort -u\n\n# Find long DNS queries (data exfiltration)\ntshark -r capture.pcap -Y 'dns' \\\n    -T fields -e dns.qry.name | awk 'length > 50'\n\n# DNS tunneling detection\n# Look for:\n# - Unusual TXT records\n# - Base64-like subdomains\n# - High frequency of queries to single domain\n\n# Extract TXT record responses\ntshark -r capture.pcap -Y 'dns.txt' \\\n    -T fields -e dns.txt\n\n# Python script to decode DNS exfiltration\nimport base64\nfrom scapy.all import *\n\ndef extract_dns_data(pcap):\n    packets = rdpcap(pcap)\n    data = []\n    \n    for pkt in packets:\n        if DNS in pkt and pkt[DNS].qr == 0:  # Query\n            query = pkt[DNS].qd.qname.decode()\n            # Extract subdomain\n            subdomain = query.split('.')[0]\n            data.append(subdomain)\n    \n    # Concatenate and decode\n    combined = ''.join(data)\n    \n    # Try base64 decode\n    try:\n        decoded = base64.b64decode(combined)\n        return decoded\n    except:\n        # Try hex decode\n        try:\n            decoded = bytes.fromhex(combined)\n            return decoded\n        except:\n            return combined\n\n# DNS query frequency analysis\ntshark -r capture.pcap -Y 'dns' \\\n    -T fields -e dns.qry.name | sort | uniq -c | sort -rn\n\n# Check for DNS C2 beaconing\n# Regular intervals suggest command and control\ntshark -r capture.pcap -Y 'dns' \\\n    -T fields -e frame.time -e dns.qry.name",
      "flag_hint": "Check TXT records and long queries for hidden data; decode base64/hex",
      "tags": ["dns", "exfiltration", "tunneling", "analysis"]
    },
    {
      "name": "HTTP Traffic Analysis",
      "desc": "Extract credentials, cookies, files, and sensitive data from HTTP traffic",
      "example": "# Extract HTTP requests\ntshark -r capture.pcap -Y 'http.request' \\\n    -T fields -e http.request.method \\\n    -e http.host -e http.request.uri\n\n# Extract POST data\ntshark -r capture.pcap -Y 'http.request.method == \"POST\"' \\\n    -T fields -e http.file_data | xxd\n\n# Extract form data\ntshark -r capture.pcap -Y 'http.request.method == \"POST\"' \\\n    -T fields -e http.request.uri -e http.file_data\n\n# Extract cookies\ntshark -r capture.pcap -Y 'http.cookie' \\\n    -T fields -e http.cookie\n\n# Extract Set-Cookie headers\ntshark -r capture.pcap -Y 'http.response' \\\n    -T fields -e http.set_cookie\n\n# Extract User-Agent\ntshark -r capture.pcap -Y 'http.request' \\\n    -T fields -e http.user_agent | sort -u\n\n# Extract HTTP authentication\ntshark -r capture.pcap -Y 'http.authorization' \\\n    -T fields -e http.authorization\n\n# Decode Basic Auth\necho \"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\" | base64 -d\n# Output: Aladdin:open sesame\n\n# Python script for HTTP analysis\nfrom scapy.all import *\nimport base64\n\ndef extract_http_data(pcap):\n    packets = rdpcap(pcap)\n    \n    for pkt in packets:\n        if TCP in pkt and Raw in pkt:\n            payload = pkt[Raw].load.decode('utf-8', errors='ignore')\n            \n            # Check for HTTP\n            if payload.startswith('POST') or payload.startswith('GET'):\n                print(\"=\" * 50)\n                print(payload)\n                \n                # Extract credentials\n                if 'Authorization: Basic' in payload:\n                    auth = payload.split('Authorization: Basic ')[1].split('\\r\\n')[0]\n                    decoded = base64.b64decode(auth).decode()\n                    print(f\"Credentials: {decoded}\")\n                \n                # Extract form data\n                if '\\r\\n\\r\\n' in payload:\n                    body = payload.split('\\r\\n\\r\\n')[1]\n                    if 'password=' in body or 'user=' in body:\n                        print(f\"Form data: {body}\")\n\n# Extract images\ntshark -r capture.pcap --export-objects http,images/\nls images/ | grep -E '\\.jpg|\\.png|\\.gif'",
      "flag_hint": "Look for POST requests with credentials, check cookies for session tokens",
      "tags": ["http", "credentials", "cookies", "extraction"]
    },
    {
      "name": "FTP Traffic Analysis",
      "desc": "Extract FTP credentials and files from network captures",
      "example": "# FTP uses two connections:\n# - Control: Port 21 (commands)\n# - Data: Port 20 or dynamic (file transfers)\n\n# Extract FTP commands\ntshark -r capture.pcap -Y 'ftp' \\\n    -T fields -e ftp.request.command -e ftp.request.arg\n\n# Extract credentials\ntshark -r capture.pcap -Y 'ftp.request.command == \"USER\" or ftp.request.command == \"PASS\"' \\\n    -T fields -e ftp.request.command -e ftp.request.arg\n\n# Example output:\n# USER admin\n# PASS password123\n\n# Follow FTP session\n# 1. Filter: ftp\n# 2. Right-click packet > Follow > TCP Stream\n# 3. See full command sequence\n\n# Extract transferred files\n# Method 1: Follow ftp-data stream\ntshark -r capture.pcap -Y 'ftp-data' -q -z follow,tcp,raw,N\n\n# Method 2: Export FTP objects\n# Wireshark: File > Export Objects > FTP-DATA\n\n# Python script\nfrom scapy.all import *\n\ndef extract_ftp_credentials(pcap):\n    packets = rdpcap(pcap)\n    user = None\n    \n    for pkt in packets:\n        if TCP in pkt and Raw in pkt:\n            payload = pkt[Raw].load.decode('utf-8', errors='ignore')\n            \n            if payload.startswith('USER '):\n                user = payload.split('USER ')[1].strip()\n                print(f\"Username: {user}\")\n            \n            elif payload.startswith('PASS '):\n                password = payload.split('PASS ')[1].strip()\n                print(f\"Password: {password}\")\n                if user:\n                    print(f\"Credentials: {user}:{password}\")\n\n# FTP commands to look for:\n# USER - Username\n# PASS - Password\n# RETR - Download file\n# STOR - Upload file\n# LIST - List directory\n# CWD - Change directory\n\n# Common filter\nftp or ftp-data",
      "flag_hint": "FTP sends credentials in plaintext - filter for USER and PASS commands",
      "tags": ["ftp", "credentials", "file-transfer", "plaintext"]
    },
    {
      "name": "SMTP/Email Traffic",
      "desc": "Extract email messages, attachments, and credentials from SMTP traffic",
      "example": "# SMTP display filter\nsmtp\n\n# Extract SMTP commands\ntshark -r capture.pcap -Y 'smtp' \\\n    -T fields -e smtp.req.command -e smtp.req.parameter\n\n# Extract email content\ntshark -r capture.pcap -Y 'smtp' -q -z follow,tcp,ascii,N\n\n# Python extraction\nfrom scapy.all import *\nimport email\nfrom email import policy\n\ndef extract_smtp_emails(pcap):\n    packets = rdpcap(pcap)\n    email_data = b''\n    \n    for pkt in packets:\n        if TCP in pkt and Raw in pkt:\n            payload = pkt[Raw].load\n            email_data += payload\n    \n    # Parse as email\n    try:\n        msg = email.message_from_bytes(email_data, policy=policy.default)\n        \n        print(f\"From: {msg['From']}\")\n        print(f\"To: {msg['To']}\")\n        print(f\"Subject: {msg['Subject']}\")\n        \n        # Extract body\n        if msg.is_multipart():\n            for part in msg.walk():\n                if part.get_content_type() == 'text/plain':\n                    print(f\"Body: {part.get_content()}\")\n        else:\n            print(f\"Body: {msg.get_content()}\")\n        \n        # Extract attachments\n        for part in msg.walk():\n            if part.get_content_disposition() == 'attachment':\n                filename = part.get_filename()\n                data = part.get_content()\n                print(f\"Attachment: {filename}\")\n                with open(filename, 'wb') as f:\n                    f.write(data)\n    except:\n        pass\n\n# Extract SMTP authentication\ntshark -r capture.pcap -Y 'smtp.req.command == \"AUTH\"'\n\n# Look for BASE64 encoded credentials\n# AUTH PLAIN base64_credentials\n\nimport base64\n\ndef decode_smtp_auth(auth_string):\n    # AUTH PLAIN: \\x00username\\x00password\n    decoded = base64.b64decode(auth_string)\n    parts = decoded.split(b'\\x00')\n    if len(parts) >= 3:\n        username = parts[1].decode()\n        password = parts[2].decode()\n        print(f\"Username: {username}\")\n        print(f\"Password: {password}\")\n\n# POP3/IMAP for receiving mail\npop\nimap\n\n# Extract POP3 credentials (plaintext)\ntshark -r capture.pcap -Y 'pop.request.command == \"USER\" or pop.request.command == \"PASS\"' \\\n    -T fields -e pop.request.command -e pop.request.parameter",
      "flag_hint": "SMTP often sends credentials base64-encoded in AUTH command",
      "tags": ["smtp", "email", "attachments", "pop3", "imap"]
    },
    {
      "name": "TLS/SSL Decryption",
      "desc": "Decrypt HTTPS traffic using SSL key logs or private keys",
      "example": "# Method 1: Using SSLKEYLOGFILE\n# Browser/app writes keys to file\n\n# Set environment variable before running browser:\nexport SSLKEYLOGFILE=/tmp/sslkeys.log\nfirefox\n\n# In Wireshark:\n# Edit > Preferences > Protocols > TLS\n# (Pre-)Master-Secret log filename: /tmp/sslkeys.log\n\n# Now HTTPS traffic decrypts to HTTP\n\n# Method 2: Using private key (if you have server key)\n# Edit > Preferences > Protocols > TLS\n# RSA keys list > Edit\n# IP: 192.168.1.1\n# Port: 443\n# Protocol: http\n# Key File: /path/to/server.key\n\n# Tshark with key log\ntshark -r capture.pcap \\\n    -o tls.keylog_file:/tmp/sslkeys.log \\\n    -Y 'http' -T fields -e http.request.uri\n\n# Extract decrypted HTTP\ntshark -r capture.pcap \\\n    -o tls.keylog_file:/tmp/sslkeys.log \\\n    -Y 'http.request.method == \"POST\"' \\\n    -T fields -e http.file_data\n\n# Python script to use SSLKEYLOGFILE\nimport os\nos.environ['SSLKEYLOGFILE'] = '/tmp/sslkeys.log'\n\nimport requests\nr = requests.get('https://example.com')\n# Keys logged to /tmp/sslkeys.log\n\n# Check TLS versions\ntshark -r capture.pcap -Y 'tls.handshake.type == 1' \\\n    -T fields -e tls.handshake.version\n\n# Extract certificates\ntshark -r capture.pcap -Y 'tls.handshake.certificate' \\\n    --export-objects tls,certs/\n\n# Analyze cipher suites\ntshark -r capture.pcap -Y 'tls.handshake.ciphersuite' \\\n    -T fields -e tls.handshake.ciphersuite",
      "flag_hint": "Use SSLKEYLOGFILE with browsers to capture TLS session keys",
      "tags": ["tls", "ssl", "https", "decryption", "sslkeylogfile"]
    },
    {
      "name": "Scapy Packet Crafting",
      "desc": "Create and manipulate packets programmatically with Scapy",
      "example": "from scapy.all import *\n\n# Read PCAP\npackets = rdpcap('capture.pcap')\nprint(f\"Total packets: {len(packets)}\")\n\n# Iterate packets\nfor pkt in packets:\n    if TCP in pkt:\n        print(f\"{pkt[IP].src}:{pkt[TCP].sport} -> {pkt[IP].dst}:{pkt[TCP].dport}\")\n\n# Filter packets\nhttp_packets = [pkt for pkt in packets if TCP in pkt and pkt[TCP].dport == 80]\n\n# Extract HTTP payloads\nfor pkt in packets:\n    if TCP in pkt and Raw in pkt:\n        payload = pkt[Raw].load\n        if b'GET ' in payload or b'POST ' in payload:\n            print(payload.decode('utf-8', errors='ignore'))\n\n# Reconstruct TCP stream\ndef reconstruct_stream(packets, src_ip, dst_ip, src_port, dst_port):\n    stream_data = b''\n    for pkt in packets:\n        if TCP in pkt and Raw in pkt:\n            if (pkt[IP].src == src_ip and pkt[IP].dst == dst_ip and\n                pkt[TCP].sport == src_port and pkt[TCP].dport == dst_port):\n                stream_data += pkt[Raw].load\n    return stream_data\n\n# Extract files from HTTP\ndef extract_http_files(packets):\n    files = []\n    current_file = b''\n    in_file = False\n    \n    for pkt in packets:\n        if TCP in pkt and Raw in pkt:\n            payload = pkt[Raw].load\n            \n            # Detect file start (HTTP response with content)\n            if b'HTTP/1' in payload and b'Content-Type:' in payload:\n                in_file = True\n                # Skip headers\n                if b'\\r\\n\\r\\n' in payload:\n                    current_file = payload.split(b'\\r\\n\\r\\n', 1)[1]\n            elif in_file:\n                current_file += payload\n                \n                # Detect file end (next HTTP request/response)\n                if b'GET ' in payload or b'POST ' in payload or b'HTTP/1' in payload:\n                    files.append(current_file)\n                    current_file = b''\n                    in_file = False\n    \n    return files\n\n# Save extracted files\nfiles = extract_http_files(packets)\nfor i, file_data in enumerate(files):\n    with open(f'extracted_{i}.bin', 'wb') as f:\n        f.write(file_data)\n\n# Craft packets\nip = IP(dst=\"192.168.1.1\")\ntcp = TCP(dport=80, flags=\"S\")\npkt = ip/tcp\nsend(pkt)\n\n# Sniff live traffic\ndef packet_callback(pkt):\n    if TCP in pkt and pkt[TCP].dport == 80:\n        print(f\"HTTP packet: {pkt.summary()}\")\n\nsniff(filter=\"tcp port 80\", prn=packet_callback, count=10)",
      "flag_hint": "Scapy provides programmatic access to all packet layers and fields",
      "tags": ["scapy", "python", "packet-crafting", "automation"]
    },
    {
      "name": "Network Forensics Checklist",
      "desc": "Systematic approach to analyzing PCAP files in CTF challenges",
      "example": "# Step-by-step analysis workflow\n\n# 1. Basic statistics\ntshark -r capture.pcap -q -z io,phs  # Protocol hierarchy\ntshark -r capture.pcap -q -z conv,tcp  # TCP conversations\ntshark -r capture.pcap -q -z endpoints,ip  # IP endpoints\n\n# 2. Search for keywords\ntshark -r capture.pcap -Y 'frame contains \"flag\"'\ntshark -r capture.pcap -Y 'frame contains \"password\"'\ntshark -r capture.pcap -Y 'frame contains \"user\"'\n\n# 3. Extract credentials\ntshark -r capture.pcap -Y 'http.authorization'\ntshark -r capture.pcap -Y 'ftp.request.command == \"USER\" or ftp.request.command == \"PASS\"'\n\n# 4. Export objects\ntshark -r capture.pcap --export-objects http,http_objects/\ntshark -r capture.pcap --export-objects smb,smb_objects/\n\n# 5. Check DNS\ntshark -r capture.pcap -Y 'dns' -T fields -e dns.qry.name | sort -u\ntshark -r capture.pcap -Y 'dns.txt' -T fields -e dns.txt\n\n# 6. Analyze suspicious ports\ntshark -r capture.pcap -Y 'tcp.port == 4444'  # Common backdoor port\ntshark -r capture.pcap -Y 'tcp.port == 31337'  # Elite port\n\n# 7. Check for data exfiltration\n# Large POST requests\ntshark -r capture.pcap -Y 'http.request.method == \"POST\" and http.content_length > 1000'\n\n# 8. Follow interesting streams\n# For each suspicious connection:\ntshark -r capture.pcap -q -z follow,tcp,ascii,N\n\n# 9. Extract and analyze files\n# Check file types\nfile http_objects/*\n\n# Search for flags in files\ngrep -r \"flag\" http_objects/\nstrings http_objects/* | grep -i flag\n\n# 10. Timeline analysis\ntshark -r capture.pcap -T fields -e frame.time -e ip.src -e ip.dst -e tcp.dstport\n\n# Automation script\n#!/bin/bash\nPCAP=$1\nOUTPUT_DIR=\"analysis_$(date +%s)\"\nmkdir -p \"$OUTPUT_DIR\"\n\necho \"[*] Analyzing $PCAP\"\n\necho \"[*] Protocol hierarchy\"\ntshark -r \"$PCAP\" -q -z io,phs > \"$OUTPUT_DIR/protocols.txt\"\n\necho \"[*] Searching for flags\"\ntshark -r \"$PCAP\" -Y 'frame contains \"flag\"' > \"$OUTPUT_DIR/flag_packets.txt\"\n\necho \"[*] Extracting HTTP objects\"\ntshark -r \"$PCAP\" --export-objects http,\"$OUTPUT_DIR/http\"\n\necho \"[*] Extracting credentials\"\ntshark -r \"$PCAP\" -Y 'http.authorization' > \"$OUTPUT_DIR/http_auth.txt\"\ntshark -r \"$PCAP\" -Y 'ftp' > \"$OUTPUT_DIR/ftp.txt\"\n\necho \"[*] DNS queries\"\ntshark -r \"$PCAP\" -Y 'dns' -T fields -e dns.qry.name | sort -u > \"$OUTPUT_DIR/dns.txt\"\n\necho \"[*] Analysis complete: $OUTPUT_DIR/\"",
      "flag_hint": "Start with protocol hierarchy, then search for keywords, then export objects",
      "tags": ["forensics", "methodology", "checklist", "workflow"]
    }
  ]
}
