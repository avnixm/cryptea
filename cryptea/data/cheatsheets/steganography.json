{
  "title": "Steganography Techniques",
  "category": "Forensics",
  "description": "Hidden data detection and extraction from images, audio, text files, and other media using various steganography methods.",
  "entries": [
    {
      "name": "Image Steganography - LSB",
      "desc": "Least Significant Bit steganography hides data in the least significant bits of pixel values",
      "example": "# Extract LSB from image\nfrom PIL import Image\nimport numpy as np\n\ndef extract_lsb(image_path, num_bits=1):\n    img = Image.open(image_path)\n    pixels = np.array(img)\n    \n    # Extract LSB from each color channel\n    bits = ''\n    for row in pixels:\n        for pixel in row:\n            for color in pixel:\n                bits += bin(color)[-num_bits:]\n    \n    # Convert bits to bytes\n    data = bytes(int(bits[i:i+8], 2) for i in range(0, len(bits), 8))\n    return data\n\n# Try with different bit depths\nfor depth in range(1, 5):\n    data = extract_lsb('image.png', depth)\n    print(f\"LSB-{depth}: {data[:100]}\")\n\n# Hide data in LSB\ndef hide_lsb(image_path, data, output_path):\n    img = Image.open(image_path)\n    pixels = np.array(img)\n    \n    # Convert data to bits\n    bits = ''.join(format(byte, '08b') for byte in data)\n    \n    # Embed bits in LSB\n    bit_idx = 0\n    for i in range(pixels.shape[0]):\n        for j in range(pixels.shape[1]):\n            for k in range(pixels.shape[2]):\n                if bit_idx < len(bits):\n                    pixels[i,j,k] = (pixels[i,j,k] & 0xFE) | int(bits[bit_idx])\n                    bit_idx += 1\n    \n    result = Image.fromarray(pixels)\n    result.save(output_path)\n\n# Tools for LSB extraction\n# stegsolve.jar - Visual LSB analysis\n# zsteg - Detect LSB steganography\n# steghide - Hide/extract with password",
      "flag_hint": "Try LSB extraction on all color channels (R, G, B) separately",
      "tags": ["stego", "lsb", "image", "pixels"]
    },
    {
      "name": "Image Metadata & EXIF",
      "desc": "Extract hidden information from image metadata, EXIF data, and file headers",
      "example": "# Extract EXIF data\nfrom PIL import Image\nfrom PIL.ExifTags import TAGS\n\nimg = Image.open('image.jpg')\nexif_data = img._getexif()\n\nfor tag_id, value in exif_data.items():\n    tag = TAGS.get(tag_id, tag_id)\n    print(f\"{tag}: {value}\")\n\n# Using exiftool (command line)\n# exiftool image.jpg\n# exiftool -all= image.jpg  # Remove all metadata\n\n# Check for GPS coordinates\nfrom exif import Image as ExifImage\n\nwith open('image.jpg', 'rb') as f:\n    img = ExifImage(f)\n    if img.has_exif:\n        if img.get('gps_latitude'):\n            print(f\"GPS: {img.gps_latitude}, {img.gps_longitude}\")\n\n# Strings in image file\nimport subprocess\nresult = subprocess.run(['strings', 'image.png'], capture_output=True)\nprint(result.stdout.decode())\n\n# Binwalk for embedded files\n# binwalk -e image.png\n# binwalk --dd='.*' image.png\n\n# Check file signature\nwith open('image.png', 'rb') as f:\n    header = f.read(16)\n    print(header.hex())\n    # PNG: 89504e47\n    # JPEG: ffd8ffe0 or ffd8ffe1\n    # GIF: 47494638\n\n# Hidden text in comments\nfrom PIL import Image\nimg = Image.open('image.png')\nif 'comment' in img.info:\n    print(img.info['comment'])",
      "flag_hint": "Check EXIF, comments, GPS data, and run binwalk for embedded files",
      "tags": ["stego", "exif", "metadata", "binwalk"]
    },
    {
      "name": "Audio Steganography",
      "desc": "Extract hidden data from audio files using spectrograms, LSB, and frequency analysis",
      "example": "# Spectrogram analysis\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.io import wavfile\nfrom scipy import signal\n\n# Load audio file\nrate, data = wavfile.read('audio.wav')\n\n# Generate spectrogram\nfrequencies, times, spectrogram = signal.spectrogram(data, rate)\n\nplt.figure(figsize=(12, 8))\nplt.pcolormesh(times, frequencies, 10 * np.log10(spectrogram))\nplt.ylabel('Frequency [Hz]')\nplt.xlabel('Time [sec]')\nplt.colorbar()\nplt.savefig('spectrogram.png')\nplt.show()\n\n# Often reveals:\n# - Text in frequency domain\n# - QR codes in spectrogram\n# - Images encoded in frequencies\n\n# Extract LSB from audio\ndef extract_audio_lsb(audio_path):\n    rate, data = wavfile.read(audio_path)\n    \n    # Extract LSB from each sample\n    bits = ''.join(str(sample & 1) for sample in data.flatten())\n    \n    # Convert to bytes\n    result = bytes(int(bits[i:i+8], 2) for i in range(0, len(bits)-7, 8))\n    return result\n\ndata = extract_audio_lsb('audio.wav')\nprint(data[:100])\n\n# Audacity for visual analysis\n# 1. Open audio file\n# 2. Analyze > Plot Spectrum\n# 3. Check for hidden frequencies\n\n# DeepSound tool for audio steganography\n# - Hides files in audio\n# - Password protection\n\n# Sonic Visualiser\n# Advanced audio analysis tool\n# View spectrograms, waveforms",
      "flag_hint": "Always check spectrogram view - hidden messages often visible as images",
      "tags": ["stego", "audio", "spectrogram", "wav"]
    },
    {
      "name": "Steghide Usage",
      "desc": "Popular steganography tool for embedding and extracting data from images and audio",
      "example": "# Basic steghide commands\n\n# Extract without password\nsteghide extract -sf image.jpg\n\n# Extract with password\nsteghide extract -sf image.jpg -p password123\n\n# Get info about embedded data\nsteghide info image.jpg\n\n# Embed data\nsteghide embed -cf image.jpg -ef secret.txt -p password\n\n# Brute force password\n# steg_brute.py from stegcracker\nstegcracker image.jpg rockyou.txt\n\n# Python wrapper\nimport subprocess\n\ndef steghide_extract(filename, password=''):\n    try:\n        cmd = ['steghide', 'extract', '-sf', filename, '-p', password]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        if 'extracted' in result.stdout:\n            return True\n    except:\n        return False\n\n# Brute force common passwords\npasswords = ['', 'password', '123456', 'admin', 'secret']\nfor pwd in passwords:\n    if steghide_extract('image.jpg', pwd):\n        print(f\"Found password: {pwd}\")\n        break\n\n# Check for steghide signature\nwith open('image.jpg', 'rb') as f:\n    data = f.read()\n    # Steghide modifies JPEG comments\n    if b'steghide' in data.lower():\n        print(\"Possibly contains steghide data\")",
      "flag_hint": "Try empty password first, then brute force with common passwords",
      "tags": ["stego", "steghide", "extraction", "password"]
    },
    {
      "name": "Zsteg for PNG/BMP",
      "desc": "Detect and extract various steganography methods in PNG and BMP images",
      "example": "# Zsteg command-line usage\n\n# Scan for all steganography methods\nzsteg image.png\n\n# Specific LSB extraction\nzsteg -E b1,rgb,lsb,xy image.png\n# b1 = 1 bit per channel\n# rgb = all channels\n# lsb = least significant bit\n# xy = row-by-row order\n\n# Extract specific channel\nzsteg -E b1,r,lsb,xy image.png  # Red channel only\nzsteg -E b1,g,lsb,xy image.png  # Green channel only\nzsteg -E b1,b,lsb,xy image.png  # Blue channel only\n\n# Different bit depths\nzsteg -E b2,rgb,lsb,xy image.png  # 2 bits per channel\nzsteg -E b4,rgb,lsb,xy image.png  # 4 bits per channel\n\n# MSB (Most Significant Bit)\nzsteg -E b1,rgb,msb,xy image.png\n\n# Save output to file\nzsteg -E b1,rgb,lsb,xy image.png > output.bin\n\n# Iterate all extractions automatically\nzsteg --all image.png\n\n# Common zsteg findings:\n# - \"text: \" - Readable text found\n# - \"file: \" - File detected (check with file command)\n# - \"zlib: \" - Compressed data\n# - \"openssl: \" - Encrypted data\n\n# Python script to try all combinations\nimport subprocess\nimport os\n\ndef zsteg_all(image_path):\n    channels = ['r', 'g', 'b', 'rgb']\n    bits = ['1', '2', '4']\n    orders = ['lsb', 'msb']\n    \n    for ch in channels:\n        for bit in bits:\n            for order in orders:\n                param = f\"b{bit},{ch},{order},xy\"\n                cmd = ['zsteg', '-E', param, image_path]\n                result = subprocess.run(cmd, capture_output=True)\n                \n                if result.stdout and len(result.stdout) > 10:\n                    print(f\"Found data with {param}:\")\n                    print(result.stdout[:200])",
      "flag_hint": "Run 'zsteg --all' first to get overview of all hidden data",
      "tags": ["stego", "zsteg", "png", "lsb"]
    },
    {
      "name": "Text Steganography",
      "desc": "Hidden messages in text using whitespace, Unicode, or encoding tricks",
      "example": "# Whitespace steganography\n# Hidden in spaces and tabs\ndef extract_whitespace(text):\n    bits = ''\n    for char in text:\n        if char == ' ':\n            bits += '0'\n        elif char == '\\t':\n            bits += '1'\n    \n    # Convert to ASCII\n    result = ''\n    for i in range(0, len(bits)-7, 8):\n        byte = bits[i:i+8]\n        result += chr(int(byte, 2))\n    \n    return result\n\n# Zero-width characters\nZERO_WIDTH_SPACE = '\\u200B'\nZERO_WIDTH_JOINER = '\\u200D'\nZERO_WIDTH_NON_JOINER = '\\u200C'\n\ndef extract_zero_width(text):\n    # Map zero-width chars to binary\n    bits = ''\n    for char in text:\n        if char == ZERO_WIDTH_SPACE:\n            bits += '0'\n        elif char == ZERO_WIDTH_JOINER:\n            bits += '1'\n    \n    # Decode\n    result = ''\n    for i in range(0, len(bits)-7, 8):\n        result += chr(int(bits[i:i+8], 2))\n    return result\n\n# Unicode homoglyphs\n# Replace characters with look-alikes\n# –ê (Cyrillic A) vs A (Latin A)\n# Detect with unicodedata\n\nimport unicodedata\n\ndef detect_homoglyphs(text):\n    for i, char in enumerate(text):\n        name = unicodedata.name(char, 'UNKNOWN')\n        if 'CYRILLIC' in name or 'GREEK' in name:\n            print(f\"Position {i}: {char} = {name}\")\n\n# Invisible ink (stegsnow for text files)\n# stegsnow -C -p password secret.txt\n# stegsnow -C -p password secret.txt > output.txt\n\n# Check for hidden data in text\ndef analyze_text(filename):\n    with open(filename, 'rb') as f:\n        data = f.read()\n    \n    # Count whitespace types\n    spaces = data.count(b' ')\n    tabs = data.count(b'\\t')\n    newlines = data.count(b'\\n')\n    \n    print(f\"Spaces: {spaces}, Tabs: {tabs}, Newlines: {newlines}\")\n    \n    # Check for zero-width characters\n    text = data.decode('utf-8', errors='ignore')\n    zw_count = sum(1 for c in text if ord(c) in [0x200B, 0x200C, 0x200D])\n    print(f\"Zero-width characters: {zw_count}\")",
      "flag_hint": "Check for unusual whitespace patterns, zero-width Unicode, or homoglyphs",
      "tags": ["stego", "text", "whitespace", "unicode"]
    },
    {
      "name": "File Carving & Embedded Files",
      "desc": "Extract hidden files embedded within other files",
      "example": "# Binwalk - Extract embedded files\n# binwalk -e file.png\n# binwalk --dd='.*' file.png  # Extract all\n\n# Foremost - File carving tool\n# foremost -i image.jpg -o output/\n\n# Manual extraction\ndef find_embedded_files(filename):\n    signatures = {\n        b'\\x89PNG': 'PNG',\n        b'\\xff\\xd8\\xff': 'JPEG',\n        b'GIF89a': 'GIF',\n        b'GIF87a': 'GIF',\n        b'PK\\x03\\x04': 'ZIP',\n        b'Rar!': 'RAR',\n        b'\\x1f\\x8b': 'GZIP',\n        b'%PDF': 'PDF',\n        b'RIFF': 'WAV/AVI',\n    }\n    \n    with open(filename, 'rb') as f:\n        data = f.read()\n    \n    for sig, filetype in signatures.items():\n        index = 0\n        while True:\n            index = data.find(sig, index)\n            if index == -1:\n                break\n            print(f\"Found {filetype} at offset {hex(index)}\")\n            index += 1\n\n# Extract from specific offset\ndef extract_at_offset(filename, offset, output):\n    with open(filename, 'rb') as f:\n        f.seek(offset)\n        data = f.read()\n    \n    with open(output, 'wb') as f:\n        f.write(data)\n\n# Check for double extensions\n# image.jpg.zip\n# file.png with ZIP appended\n\nimport zipfile\nimport os\n\ndef check_zip_appended(filename):\n    try:\n        # Try to open as ZIP from end\n        with zipfile.ZipFile(filename, 'r') as z:\n            print(f\"ZIP file found in {filename}\")\n            z.extractall('extracted/')\n            return True\n    except:\n        return False\n\n# Check for concatenated files\ndef split_concatenated(filename):\n    with open(filename, 'rb') as f:\n        data = f.read()\n    \n    # Find secondary PNG header\n    second_png = data.find(b'\\x89PNG', 1)\n    if second_png != -1:\n        print(f\"Second PNG at offset {hex(second_png)}\")\n        with open('second.png', 'wb') as f:\n            f.write(data[second_png:])",
      "flag_hint": "Run binwalk first, then check for ZIP/RAR appended to images",
      "tags": ["stego", "binwalk", "carving", "embedded"]
    },
    {
      "name": "QR Code & Barcode Stego",
      "desc": "Hidden QR codes in images, spectrograms, or manipulated barcodes",
      "example": "# Decode QR code from image\nfrom pyzbar.pyzbar import decode\nfrom PIL import Image\n\ndef decode_qr(image_path):\n    img = Image.open(image_path)\n    codes = decode(img)\n    \n    for code in codes:\n        print(f\"Type: {code.type}\")\n        print(f\"Data: {code.data.decode()}\")\n        print(f\"Position: {code.rect}\")\n\n# Try on modified versions\nfrom PIL import ImageFilter, ImageEnhance\n\ndef try_filters(image_path):\n    img = Image.open(image_path)\n    \n    # Original\n    decode_qr(image_path)\n    \n    # Inverted\n    from PIL import ImageOps\n    inverted = ImageOps.invert(img.convert('RGB'))\n    inverted.save('inverted.png')\n    decode_qr('inverted.png')\n    \n    # High contrast\n    enhancer = ImageEnhance.Contrast(img)\n    high_contrast = enhancer.enhance(5.0)\n    high_contrast.save('contrast.png')\n    decode_qr('contrast.png')\n    \n    # Threshold (black and white)\n    threshold = img.convert('L').point(lambda x: 0 if x < 128 else 255, '1')\n    threshold.save('threshold.png')\n    decode_qr('threshold.png')\n\n# QR code in spectrogram\n# 1. Generate spectrogram from audio\n# 2. Scan spectrogram image for QR code\n\nfrom scipy.io import wavfile\nfrom scipy import signal\nimport matplotlib.pyplot as plt\n\nrate, data = wavfile.read('audio.wav')\nf, t, Sxx = signal.spectrogram(data, rate)\n\nplt.figure(figsize=(10, 10))\nplt.pcolormesh(t, f, 10 * np.log10(Sxx), cmap='gray')\nplt.axis('off')\nplt.savefig('spec_qr.png', bbox_inches='tight', pad_inches=0)\n\n# Now scan spec_qr.png for QR code\ndecode_qr('spec_qr.png')\n\n# Online QR decoder\n# zxing.org/w/decode\n# webqr.com\n\n# Generate QR code\nimport qrcode\nqr = qrcode.QRCode(version=1, box_size=10, border=5)\nqr.add_data('flag{hidden_in_qr}')\nqr.make(fit=True)\nimg = qr.make_image(fill_color=\"black\", back_color=\"white\")\nimg.save('qr.png')",
      "flag_hint": "Try inverting colors, adjusting contrast, or converting to black/white",
      "tags": ["stego", "qr-code", "barcode", "pyzbar"]
    },
    {
      "name": "Stegsolve Techniques",
      "desc": "Using Stegsolve.jar for visual steganography analysis",
      "example": "# Stegsolve.jar is a GUI tool - key features:\n\n# 1. File Format > Open image\n# 2. Analyse > Data Extract\n#    - Try different:\n#      - Bit planes (0-7)\n#      - Order: RGB, BGR, etc.\n#      - LSB/MSB\n#    - Preview shows extracted data\n#    - Save to file\n\n# 3. Analyse > Frame Browser\n#    - View each bit plane separately\n#    - Often reveals hidden images\n#    - Toggle through: Red 0, Red 1, ... Blue 7\n\n# 4. Analyse > Image Combiner\n#    - XOR/ADD/SUB two images\n#    - Reveals differences\n#    - Load two similar images\n#    - Apply operations to find changes\n\n# 5. Analyse > Stereogram Solver\n#    - For magic eye images\n\n# Python equivalent for bit plane analysis\nfrom PIL import Image\nimport numpy as np\n\ndef extract_bit_plane(image_path, channel, bit):\n    img = Image.open(image_path)\n    pixels = np.array(img)\n    \n    # Extract specific bit from specific channel\n    # channel: 0=R, 1=G, 2=B\n    bit_plane = (pixels[:, :, channel] >> bit) & 1\n    \n    # Convert to image (0 or 255)\n    result = (bit_plane * 255).astype(np.uint8)\n    \n    return Image.fromarray(result)\n\n# Extract all bit planes\nfor channel in range(3):\n    channel_names = ['red', 'green', 'blue']\n    for bit in range(8):\n        img = extract_bit_plane('image.png', channel, bit)\n        img.save(f'bitplane_{channel_names[channel]}_{bit}.png')\n\n# XOR two images\ndef xor_images(img1_path, img2_path):\n    img1 = np.array(Image.open(img1_path))\n    img2 = np.array(Image.open(img2_path))\n    \n    xored = np.bitwise_xor(img1, img2)\n    return Image.fromarray(xored)\n\nresult = xor_images('image1.png', 'image2.png')\nresult.save('xored.png')",
      "flag_hint": "Check all bit planes (0-7) for each color channel - hidden images often in LSB",
      "tags": ["stego", "stegsolve", "bit-planes", "visual"]
    },
    {
      "name": "Steganography Tool Suite",
      "desc": "Comprehensive list of steganography detection and extraction tools",
      "example": "# Analysis Tools\n\n# stegdetect - Detect steganography in images\nstegdetect -s 10.0 image.jpg\n\n# stegbreak - Brute force stegdetect\nstegbreak -t p -f wordlist.txt image.jpg\n\n# StegExpose - Statistical steg detection\njava -jar StegExpose.jar image.png\n\n# Extraction Tools\n\n# steghide - JPEG/BMP/WAV/AU\nsteghide extract -sf image.jpg\n\n# zsteg - PNG/BMP LSB\nzsteg --all image.png\n\n# outguess - JPEG\noutguess -r image.jpg output.txt\n\n# jsteg - JPEG LSB\njsteg reveal image.jpg output.txt\n\n# stegpy - Python LSB tool\nstegpy image.png -o\n\n# Audio Tools\n\n# Audacity - Spectrogram analysis\n# Sonic Visualiser - Advanced audio analysis\n# DeepSound - Audio steganography\n# WavSteg - WAV file LSB\n\n# File Carving\n\n# binwalk - Extract embedded files\nbinwalk -e file\n\n# foremost - File carving\nforemost -i file -o output/\n\n# bulk_extractor - Extract features\nbulk_extractor -o output file\n\n# scalpel - Fast file carving\nscalpel file -o output/\n\n# Metadata\n\n# exiftool - Image metadata\nexiftool -all image.jpg\n\n# strings - Extract strings\nstrings file | grep -i flag\n\n# hexdump - Hex analysis\nhexdump -C file | less\n\n# Quick scan script\n#!/bin/bash\nFILE=$1\n\necho \"[*] Running strings...\"\nstrings \"$FILE\" | grep -i \"flag\\|password\\|key\"\n\necho \"[*] Running binwalk...\"\nbinwalk -e \"$FILE\"\n\necho \"[*] Running exiftool...\"\nexiftool \"$FILE\"\n\nif [[ \"$FILE\" == *.png ]] || [[ \"$FILE\" == *.bmp ]]; then\n    echo \"[*] Running zsteg...\"\n    zsteg --all \"$FILE\"\nfi\n\nif [[ \"$FILE\" == *.jpg ]] || [[ \"$FILE\" == *.jpeg ]]; then\n    echo \"[*] Running steghide...\"\n    steghide info \"$FILE\"\nfi",
      "flag_hint": "Start with automated tools, then manual analysis on promising findings",
      "tags": ["stego", "tools", "automation", "suite"]
    }
  ]
}
